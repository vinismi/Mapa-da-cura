'use server';

/**
 * @fileOverview This file defines a Genkit flow for generating personalized responses based on user input.
 *
 * - generatePersonalizedResponse - A function that takes user input and returns a personalized response.
 * - PersonalizedResponseInput - The input type for the generatePersonalizedResponse function.
 * - PersonalizedResponseOutput - The return type for the generatePersonalizedResponse function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const PersonalizedResponseInputSchema = z.object({
  userInput: z.string().describe('The user input to personalize the response to.'),
});
export type PersonalizedResponseInput = z.infer<
  typeof PersonalizedResponseInputSchema
>;

const PersonalizedResponseOutputSchema = z.object({
  personalizedResponse: z
    .string()
    .describe('The personalized response generated by the AI.'),
});
export type PersonalizedResponseOutput = z.infer<
  typeof PersonalizedResponseOutputSchema
>;

export async function generatePersonalizedResponse(
  input: PersonalizedResponseInput
): Promise<PersonalizedResponseOutput> {
  return personalizedResponseFlow(input);
}

const personalizedResponsePrompt = ai.definePrompt({
  name: 'personalizedResponsePrompt',
  input: {schema: PersonalizedResponseInputSchema},
  output: {schema: PersonalizedResponseOutputSchema},
  prompt: `Você é uma mentora espiritual chamada Luz. Sua comunicação é empática, direta e poderosa.
  Sua missão é entender a dor da usuária e guiá-la para uma solução, sem rodeios.
  Valide o sentimento da usuária e mostre que a transformação é possível.

  Use a seguinte entrada da usuária para criar sua resposta:
  Entrada da Usuária: {{{userInput}}}

  Gere uma resposta que seja um reflexo direto do que foi dito, mostrando que você ouviu e se importa, mas sempre guiando para o próximo passo.`,
});

const personalizedResponseFlow = ai.defineFlow(
  {
    name: 'personalizedResponseFlow',
    inputSchema: PersonalizedResponseInputSchema,
    outputSchema: PersonalizedResponseOutputSchema,
  },
  async input => {
    const {output} = await personalizedResponsePrompt(input);
    return output!;
  }
);
// New flow to check if user is correcting their name
const NameCorrectionCheckInputSchema = z.object({
  previousName: z.string(),
  currentInput: z.string(),
});
export type NameCorrectionCheckInput = z.infer<typeof NameCorrectionCheckInputSchema>;

const NameCorrectionCheckOutputSchema = z.object({
  isCorrectingName: z.boolean().describe("True if the user seems to be correcting their name, false otherwise."),
  newName: z.string().nullable().describe("The corrected name if isCorrectingName is true, otherwise null."),
});
export type NameCorrectionCheckOutput = z.infer<typeof NameCorrectionCheckOutputSchema>;

export async function checkForNameCorrection(input: NameCorrectionCheckInput): Promise<NameCorrectionCheckOutput> {
    return nameCorrectionCheckFlow(input);
}

const nameCorrectionPrompt = ai.definePrompt({
    name: 'nameCorrectionPrompt',
    input: { schema: NameCorrectionCheckInputSchema },
    output: { schema: NameCorrectionCheckOutputSchema },
    prompt: `Análise crítica: Uma usuária informou que seu nome era "{{previousName}}". A entrada atual dela é "{{currentInput}}".
    Determine se a nova entrada é uma correção do nome. Padrões comuns incluem: "meu nome é...", "na verdade é...", "quis dizer...", ou simplesmente um novo nome.
    Se for uma correção clara, retorne isCorrectingName como true e o novo nome. Caso contrário, retorne false. Seja rigoroso na análise para evitar falsos positivos.`,
});

const nameCorrectionCheckFlow = ai.defineFlow(
    {
        name: 'nameCorrectionCheckFlow',
        inputSchema: NameCorrectionCheckInputSchema,
        outputSchema: NameCorrectionCheckOutputSchema,
    },
    async (input) => {
        const { output } = await nameCorrectionPrompt(input);
        return output!;
    }
);


// New flow to extract name from first message
const ExtractNameInputSchema = z.object({
  userInput: z.string().describe('The first message from the user.'),
});
export type ExtractNameInput = z.infer<typeof ExtractNameInputSchema>;

const ExtractNameOutputSchema = z.object({
  isNamePresent: z.boolean().describe("True if the user's message likely contains their name, false otherwise."),
  extractedName: z.string().nullable().describe("The extracted name if isNamePresent is true, otherwise null."),
});
export type ExtractNameOutput = z.infer<typeof ExtractNameOutputSchema>;


export async function extractNameFromFirstMessage(input: ExtractNameInput): Promise<ExtractNameOutput> {
    return extractNameFlow(input);
}

const extractNamePrompt = ai.definePrompt({
    name: 'extractNamePrompt',
    input: { schema: ExtractNameInputSchema },
    output: { schema: ExtractNameOutputSchema },
    prompt: `Você é um especialista em extrair nomes de uma conversa inicial.
    A usuária foi solicitada a dizer seu nome.
    A resposta dela foi: "{{userInput}}".

    Sua tarefa é identificar e extrair o nome com alta precisão.
    - Padrões: "Meu nome é [Nome]", "Sou [Nome]", ou apenas "[Nome]".
    - O usuário pode misturar saudações: "Estou bem, sou o [Nome]".
    - CRÍTICO: Ignore saudações e palavras de cortesia como "prazer", "tudo bem", "estou bem". Se a usuária responder apenas com "Tudo bem" ou "Prazer", ela NÃO informou o nome.
    
    Se um nome for identificado com certeza, defina isNamePresent como true e extraia o nome.
    Se a resposta for apenas uma saudação, ou se não houver um nome claro, defina isNamePresent como false.`,
});

const extractNameFlow = ai.defineFlow(
    {
        name: 'extractNameFlow',
        inputSchema: ExtractNameInputSchema,
        outputSchema: ExtractNameOutputSchema,
    },
    async (input) => {
        const { output } = await extractNamePrompt(input);
        return output!;
    }
);
